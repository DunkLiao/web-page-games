<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‚¥å°¾å¤§å†’éšªï¼šè±¹ç´‹å®ˆå®®çš„èŸ²èŸ²è¨ˆæ™‚è³½</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            /* å…è¨±ç¶²é æ­£å¸¸æ²å‹• */
            touch-action: pan-y;
            user-select: none;
            background-color: #fef3c7; 
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif;
            -webkit-overflow-scrolling: touch;
        }
        #game-canvas {
            max-width: 100%;
            height: auto;
            border-radius: 20px;
            box-shadow: 0 10px 25px -5px rgba(146, 64, 14, 0.3);
            background-color: #fffbeb;
            /* åƒ…åœ¨ç•«å¸ƒä¸Šç¦ç”¨è§¸æ§é è¨­è¡Œç‚ºï¼Œé˜²æ­¢æ»‘å‹•æ™‚ç§»å‹•ç¶²é  */
            touch-action: none;
        }
        /* å¯æ„›æŒ‰éˆ•é¢¨æ ¼ */
        .control-btn {
            background: linear-gradient(to bottom, #ffffff, #fffbeb);
            border-bottom: 6px solid #f59e0b;
            border-radius: 9999px;
            transition: all 0.1s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .control-btn:active {
            border-bottom-width: 0;
            transform: translateY(6px);
            background: #fffbeb;
            box-shadow: none;
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-4 overflow-y-auto">

    <!-- æ¨™é¡Œå€åŸŸ -->
    <div class="w-full max-w-md text-center mb-4">
        <h1 class="text-3xl font-black text-amber-600 mb-1 drop-shadow-sm">ğŸ¦ è‚¥å°¾å¤§å†’éšª</h1>
        <p class="text-amber-800 text-sm mb-3 font-bold">å°è±¹ç´‹å®ˆå®®çš„èŸ²èŸ²æŒ‘æˆ°ï¼</p>
        
        <div class="flex justify-between items-center bg-white/90 backdrop-blur-sm p-3 rounded-2xl shadow-sm border-2 border-amber-200">
            <div class="flex flex-col items-start">
                <span class="text-[10px] text-amber-700 font-black uppercase tracking-wider">é—œå¡</span>
                <span id="level-display" class="text-xl font-black text-amber-900">1</span>
            </div>
            <div class="flex flex-col items-center">
                <span class="text-[10px] text-amber-700 font-black uppercase tracking-wider">æ™‚é–“</span>
                <span id="timer-display" class="text-xl font-black text-amber-900">00:00</span>
            </div>
            <div class="flex flex-col items-center">
                <span class="text-[10px] text-amber-700 font-black uppercase tracking-wider">æ­¥æ•¸</span>
                <span id="steps-display" class="text-xl font-black text-amber-900">0</span>
            </div>
            <div class="flex flex-col items-end">
                <span class="text-[10px] text-amber-700 font-black uppercase tracking-wider">é›£åº¦</span>
                <span id="difficulty-display" class="text-sm font-bold text-amber-600">æ™®é€š</span>
            </div>
        </div>
    </div>

    <!-- éŠæˆ²å€åŸŸ -->
    <div class="relative bg-amber-800 p-2.5 rounded-[24px] shadow-2xl border-4 border-amber-900">
        <canvas id="game-canvas"></canvas>
        
        <!-- å‹åˆ©ç•«é¢ -->
        <div id="win-modal" class="absolute inset-0 bg-amber-900/80 flex flex-col items-center justify-center hidden rounded-[20px] backdrop-blur-md z-20">
            <div class="bg-white p-6 rounded-[32px] text-center shadow-2xl border-4 border-amber-400 max-w-[85%] transform scale-105">
                <div class="text-6xl mb-3">ğŸ˜‹</div>
                <h2 class="text-2xl font-black text-amber-700 mb-1">æŠ“åˆ°äº†ï¼å¥½æ»¿è¶³</h2>
                <div class="bg-amber-50 p-4 rounded-2xl mb-5 border border-amber-100">
                    <p class="text-sm text-amber-800 font-bold">è€—æ™‚ï¼š<span id="final-time" class="text-xl">00:00</span></p>
                    <p class="text-xs text-amber-600 font-medium">ä½¿ç”¨äº† <span id="final-steps">0</span> æ­¥</p>
                </div>
                <button id="next-level-btn" class="bg-amber-500 hover:bg-amber-600 text-white font-black py-4 px-10 rounded-full shadow-[0_6px_0_#d97706] transition-all active:shadow-none active:translate-y-[6px] w-full text-lg">
                    ç¹¼çºŒå†’éšª âœ¨
                </button>
            </div>
        </div>
    </div>

    <!-- æ§åˆ¶æŒ‰éˆ•å€ (ç¾åœ¨å§‹çµ‚é¡¯ç¤º) -->
    <div class="flex flex-col items-center mt-8 pb-4 w-full max-w-[280px]">
        <div class="grid grid-cols-3 gap-4">
            <div></div>
            <button id="btn-up" class="control-btn w-16 h-16">â¬†ï¸</button>
            <div></div>
            <button id="btn-left" class="control-btn w-16 h-16">â¬…ï¸</button>
            <button id="btn-down" class="control-btn w-16 h-16">â¬‡ï¸</button>
            <button id="btn-right" class="control-btn w-16 h-16">â¡ï¸</button>
        </div>
    </div>

    <!-- è¨­å®šèˆ‡æ§åˆ¶åˆ— -->
    <div class="mt-4 mb-12 flex items-center gap-3 w-full max-w-md justify-center">
        <select id="difficulty-select" class="bg-white border-2 border-amber-200 text-amber-900 font-black py-2.5 px-4 rounded-2xl focus:outline-none focus:ring-4 focus:ring-amber-500/20 shadow-sm text-sm cursor-pointer">
            <option value="10">ç°¡å–®æ¨¡å¼</option>
            <option value="15" selected>æ™®é€šæ¨¡å¼</option>
            <option value="25">å›°é›£æ¨¡å¼</option>
        </select>
        <button id="reset-btn" class="bg-amber-100 hover:bg-amber-200 text-amber-800 font-black py-2.5 px-6 rounded-2xl transition-all border-2 border-amber-200 text-sm shadow-sm active:scale-95">
            é‡æ–°é–‹å§‹
        </button>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const stepsDisplay = document.getElementById('steps-display');
        const levelDisplay = document.getElementById('level-display');
        const timerDisplay = document.getElementById('timer-display');
        const difficultyDisplay = document.getElementById('difficulty-display');
        const difficultySelect = document.getElementById('difficulty-select');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const resetBtn = document.getElementById('reset-btn');
        const winModal = document.getElementById('win-modal');
        const finalTimeDisplay = document.getElementById('final-time');
        const finalStepsDisplay = document.getElementById('final-steps');

        let gridSize = 15;
        let cellSize = 0;
        let maze = [];
        let player = { x: 0, y: 0 };
        let goal = { x: 0, y: 0 };
        let steps = 0;
        let level = 1;

        // è¨ˆæ™‚å™¨é‚è¼¯
        let seconds = 0;
        let timerInterval = null;
        let gameStarted = false;

        function startTimer() {
            if (timerInterval) return;
            timerInterval = setInterval(() => {
                seconds++;
                updateTimerUI();
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        function updateTimerUI() {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            timerDisplay.innerText = `${mins}:${secs}`;
        }

        function initGame() {
            stopTimer();
            gridSize = parseInt(difficultySelect.value);
            const size = Math.min(window.innerWidth - 60, 450);
            canvas.width = size;
            canvas.height = size;
            cellSize = canvas.width / gridSize;
            difficultyDisplay.innerText = difficultySelect.options[difficultySelect.selectedIndex].text.replace('æ¨¡å¼', '');
            
            generateMaze();
            player = { x: 0, y: 0 };
            goal = { x: gridSize - 1, y: gridSize - 1 };
            
            steps = 0;
            seconds = 0;
            gameStarted = false;
            
            stepsDisplay.innerText = steps;
            updateTimerUI();
            winModal.classList.add('hidden');
            draw();
        }

        function generateMaze() {
            maze = Array(gridSize).fill().map(() => Array(gridSize).fill().map(() => ({
                visited: false,
                walls: { top: true, right: true, bottom: true, left: true }
            })));

            const stack = [];
            const startNode = { x: 0, y: 0 };
            maze[0][0].visited = true;
            stack.push(startNode);

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = getUnvisitedNeighbors(current.x, current.y);

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    removeWalls(current, next);
                    maze[next.y][next.x].visited = true;
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }
        }

        function getUnvisitedNeighbors(x, y) {
            const neighbors = [];
            if (y > 0 && !maze[y - 1][x].visited) neighbors.push({ x: x, y: y - 1 });
            if (y < gridSize - 1 && !maze[y + 1][x].visited) neighbors.push({ x: x, y: y + 1 });
            if (x > 0 && !maze[y][x - 1].visited) neighbors.push({ x: x - 1, y: y });
            if (x < gridSize - 1 && !maze[y][x + 1].visited) neighbors.push({ x: x + 1, y: y });
            return neighbors;
        }

        function removeWalls(a, b) {
            if (a.x === b.x) {
                if (a.y > b.y) { 
                    maze[a.y][a.x].walls.top = false; 
                    maze[b.y][b.x].walls.bottom = false; 
                } else { 
                    maze[a.y][a.x].walls.bottom = false; 
                    maze[b.y][b.x].walls.top = false; 
                }
            } else if (a.y === b.y) {
                if (a.x > b.x) { 
                    maze[a.y][a.x].walls.left = false; 
                    maze[b.y][b.x].walls.right = false; 
                } else { 
                    maze[a.y][a.x].walls.right = false; 
                    maze[b.y][b.x].walls.left = false; 
                }
            }
        }

        // ç¹ªè£½å¯æ„›çš„å®ˆå®®ä¸»è§’
        function drawLeopardGecko(x, y) {
            const centerX = x * cellSize + cellSize / 2;
            const centerY = y * cellSize + cellSize / 2;
            const size = cellSize * 0.8;
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // å®ˆå®®é…è‰²èˆ‡èº«é«”çµæ§‹
            ctx.fillStyle = '#fbbf24'; 
            
            // è‚¥å°¾å·´ (æ ¸å¿ƒç‰¹è‰²)
            ctx.beginPath();
            ctx.ellipse(-size/4, size/6, size/3, size/5, Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            
            // åœ“åœ“çš„èº«é«”
            ctx.beginPath();
            ctx.ellipse(0, 0, size/2.5, size/4, 0, 0, Math.PI * 2);
            ctx.fill();

            // å¯æ„›çš„å¤§é ­
            ctx.beginPath();
            ctx.ellipse(size/3, -size/8, size/4, size/5, -Math.PI/10, 0, Math.PI * 2);
            ctx.fill();

            // è±¹ç´‹æ–‘é»
            ctx.fillStyle = '#1e1b4b';
            [[0,0], [size/6, size/10], [-size/6, -size/10], [size/3, -size/10], [-size/4, size/8]].forEach(s => {
                ctx.beginPath(); ctx.arc(s[0], s[1], size/20, 0, Math.PI * 2); ctx.fill();
            });

            // äº®æ™¶æ™¶çš„å°çœ¼ç›
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(size/2.5, -size/6, size/25, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = Math.max(2, cellSize / 10);
            ctx.lineCap = 'round';

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = maze[y][x];
                    const px = x * cellSize; 
                    const py = y * cellSize;
                    if (cell.walls.top) { ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px + cellSize, py); ctx.stroke(); }
                    if (cell.walls.right) { ctx.beginPath(); ctx.moveTo(px + cellSize, py); ctx.lineTo(px + cellSize, py + cellSize); ctx.stroke(); }
                    if (cell.walls.bottom) { ctx.beginPath(); ctx.moveTo(px, py + cellSize); ctx.lineTo(px + cellSize, py + cellSize); ctx.stroke(); }
                    if (cell.walls.left) { ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, py + cellSize); ctx.stroke(); }
                }
            }

            // ç¹ªè£½ç›®æ¨™ï¼šéºµåŒ…èŸ²
            ctx.font = `${cellSize * 0.7}px Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ›', goal.x * cellSize + cellSize / 2, goal.y * cellSize + cellSize / 2);

            // ç¹ªè£½ä¸»è§’ï¼šè‚¥å°¾å®ˆå®®
            drawLeopardGecko(player.x, player.y);
        }

        function move(dir) {
            if (!winModal.classList.contains('hidden')) return;
            
            if (!gameStarted) {
                gameStarted = true;
                startTimer();
            }

            const currentCell = maze[player.y][player.x];
            let moved = false;
            if (dir === 'up' && !currentCell.walls.top) { player.y--; moved = true; }
            else if (dir === 'down' && !currentCell.walls.bottom) { player.y++; moved = true; }
            else if (dir === 'left' && !currentCell.walls.left) { player.x--; moved = true; }
            else if (dir === 'right' && !currentCell.walls.right) { player.x++; moved = true; }
            
            if (moved) {
                steps++; 
                stepsDisplay.innerText = steps; 
                draw();
                if (player.x === goal.x && player.y === goal.y) {
                    stopTimer();
                    finalTimeDisplay.innerText = timerDisplay.innerText;
                    finalStepsDisplay.innerText = steps;
                    winModal.classList.remove('hidden');
                }
            }
        }

        // éµç›¤æ“æ§
        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'w', 'W'].includes(e.key)) { e.preventDefault(); move('up'); }
            if (['ArrowDown', 's', 'S'].includes(e.key)) { e.preventDefault(); move('down'); }
            if (['ArrowLeft', 'a', 'A'].includes(e.key)) { e.preventDefault(); move('left'); }
            if (['ArrowRight', 'd', 'D'].includes(e.key)) { e.preventDefault(); move('right'); }
        });

        // æŒ‰éˆ•é»æ“Šæ“æ§
        document.getElementById('btn-up').onclick = () => move('up');
        document.getElementById('btn-down').onclick = () => move('down');
        document.getElementById('btn-left').onclick = () => move('left');
        document.getElementById('btn-right').onclick = () => move('right');
        
        nextLevelBtn.onclick = () => { level++; levelDisplay.innerText = level; initGame(); };
        resetBtn.onclick = () => { level = 1; levelDisplay.innerText = level; initGame(); };
        difficultySelect.onchange = initGame;
        
        window.onload = initGame;
        window.addEventListener('resize', initGame);
    </script>
</body>
</html>